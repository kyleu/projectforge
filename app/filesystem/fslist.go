// Code generated by Project Forge, see https://projectforge.dev for details.
package filesystem

import (
	"io/ioutil"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/kyleu/projectforge/app/util"
)

var defaultIgnore = []string{".DS_Store", ".git", ".idea", "build", ".html.go", ".sql.go"}

func (f *FileSystem) ListFiles(path string, ign []string) []os.FileInfo {
	ignore := buildIgnore(ign)
	infos, err := ioutil.ReadDir(filepath.Join(f.root, path))
	if err != nil {
		f.logger.Warnf("cannot list files in path [%s]: %+v", path, err)
	}
	ret := make([]os.FileInfo, 0, len(infos))
	for _, info := range infos {
		if !checkIgnore(ignore, info.Name()) {
			ret = append(ret, info)
		}
	}

	for _, c := range f.children {
		kids := c.ListFiles(path, ignore)
		for _, kid := range kids {
			present := false
			for _, match := range ret {
				if match.Name() == kid.Name() {
					present = true
				}
			}
			if !present {
				ret = append(ret, kid)
			}
		}
	}

	return ret
}

func (f *FileSystem) ListJSON(path string, trimExtension bool) []string {
	return f.ListExtension(path, "json", trimExtension)
}

func (f *FileSystem) ListExtension(path string, ext string, trimExtension bool) []string {
	glob := "*." + ext
	matches, err := filepath.Glob(f.getPath(path, glob))
	if err != nil {
		f.logger.Warnf("cannot list [%s] in path [%s]: %+v", ext, path, err)
	}
	ret := make([]string, 0, len(matches))
	for _, j := range matches {
		idx := strings.LastIndex(j, "/")
		if idx > 0 {
			j = j[idx+1:]
		}
		if trimExtension {
			j = strings.TrimSuffix(j, "."+ext)
		}
		ret = append(ret, j)
	}

	for _, c := range f.children {
		kids := c.ListExtension(path, ext, trimExtension)
		for _, kid := range kids {
			if !util.StringArrayContains(ret, kid) {
				ret = append(ret, kid)
			}
		}
	}

	sort.Strings(ret)
	return ret
}

func (f *FileSystem) ListDirectories(path string) []string {
	if !f.Exists(path) {
		return nil
	}
	p := f.getPath(path)
	files, err := ioutil.ReadDir(p)
	if err != nil {
		f.logger.Warnf("cannot list path [%s]: %+v", path, err)
	}
	var ret []string
	for _, f := range files {
		if f.IsDir() {
			ret = append(ret, f.Name())
		}
	}

	for _, c := range f.children {
		kids := c.ListDirectories(path)
		for _, kid := range kids {
			if !util.StringArrayContains(ret, kid) {
				ret = append(ret, kid)
			}
		}
	}

	sort.Strings(ret)
	return ret
}

func (f *FileSystem) ListFilesRecursive(path string, ign []string) ([]string, error) {
	ignore := buildIgnore(ign)
	p := f.getPath(path)
	var ret []string
	err := filepath.Walk(p, func(fp string, info os.FileInfo, err error) error {
		m := strings.TrimPrefix(fp, p + "/")
		if checkIgnore(ignore, m) {
			return nil
		}
		if !info.IsDir() && strings.Contains(fp, "/") {
			ret = append(ret, m)
		}
		return nil
	})
	if err != nil {
		return nil, err
	}

	for _, c := range f.children {
		kids, err := c.ListFilesRecursive(path, ignore)
		if err != nil {
			return nil, err
		}
		for _, kid := range kids {
			if !util.StringArrayContains(ret, kid) {
				ret = append(ret, kid)
			}
		}
	}

	sort.Strings(ret)
	return ret, nil
}

func buildIgnore(ign []string) []string {
	ret := append([]string{}, defaultIgnore...)
	ret = append(ret, ign...)
	return ret
}

func checkIgnore(ignore []string, fp string) bool {
	for _, i := range ignore {
		if strings.HasPrefix(fp, i) || strings.HasSuffix(fp, i) {
			return true
		}
	}
	return false
}
