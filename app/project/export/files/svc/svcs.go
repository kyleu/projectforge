package svc

import (
	"fmt"

	"github.com/samber/lo"

	"projectforge.dev/projectforge/app/file"
	"projectforge.dev/projectforge/app/lib/metamodel"
	"projectforge.dev/projectforge/app/lib/metamodel/model"
	"projectforge.dev/projectforge/app/project/export/files/helper"
	"projectforge.dev/projectforge/app/project/export/golang"
	"projectforge.dev/projectforge/app/util"
)

func Services(args *metamodel.Args, linebreak string) (*file.File, error) {
	g := golang.NewFile("app", []string{"app"}, "generated")
	g.AddImport(helper.ImpContext, helper.ImpAppUtil)
	if args.HasModule("audit") {
		g.AddImport(helper.ImpAudit)
	}
	for _, m := range args.Models.WithService() {
		g.AddImport(helper.AppImport(m.PackageWithGroup("")))
	}

	var svcSize int
	lo.ForEach(args.Models.WithService(), func(m *model.Model, _ int) {
		if len(m.Proper()) > svcSize {
			svcSize = len(m.Proper())
		}
	})

	initParamsArr := []string{"st *State"}
	if args.HasModule("audit") {
		initParamsArr = append(initParamsArr, "audSvc *audit.Service")
	}
	initParams := util.StringJoin(initParamsArr, ", ")

	svcs := make([]string, 0, len(args.Models))
	refs := make([]string, 0, len(args.Models))
	lo.ForEach(args.Models.WithService(), func(m *model.Model, _ int) {
		svcs = append(svcs, fmt.Sprintf("%s *%s.Service", util.StringPad(m.Proper(), svcSize), m.Package))

		refParamsArr := []string{"st.DB"}
		if args.HasModule("readonlydb") && !m.HasTag("audit") {
			refParamsArr = append(refParamsArr, "st.DBRead")
		}
		if args.HasModule("audit") && m.HasTag("audit") {
			refParamsArr = append(refParamsArr, "audSvc")
		}
		refParams := util.StringJoin(refParamsArr, ", ")

		refs = append(refs, fmt.Sprintf("%s %s.NewService(%s),", util.StringPad(m.Proper()+":", svcSize+1), m.Package, refParams))
	})

	g.AddBlocks(servicesStruct(svcs), servicesInitFn(refs, initParams))
	return g.Render(linebreak)
}

func servicesStruct(svcs []string) *golang.Block {
	ret := golang.NewBlock("genStruct", "struct")
	if len(svcs) == 0 {
		ret.W("type GeneratedServices struct{}")
		return ret
	}
	ret.W("type GeneratedServices struct {")
	for _, svc := range svcs {
		ret.W("\t" + svc)
	}
	ret.W("}")
	return ret
}

func servicesInitFn(refs []string, params string) *golang.Block {
	ret := golang.NewBlock("initGeneratedServices", "func")
	ret.WF("func initGeneratedServices(ctx context.Context, %s, logger util.Logger) GeneratedServices {", params)
	if len(refs) == 0 {
		ret.W("\treturn GeneratedServices{}")
		ret.W("}")
		return ret
	}
	ret.W("\treturn GeneratedServices{")
	for _, svc := range refs {
		ret.W("\t\t" + svc)
	}
	ret.W("\t}")
	ret.W("}")
	return ret
}
